<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<title>WebSocket chat demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
    body, input, textarea, button, select {
        font: inherit;
    }

    pre {
        white-space: pre-wrap;
    }

    :root {
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 100%;
    }

    body {
        display: grid;
    }

    #text {
        margin: 0;
        display: block;
        border: solid .125rem #aaa;
        padding: .5em;
        appearance: none;
        box-sizing: border-box;
        overflow: hidden;
        white-space: pre-wrap;
        position: fixed;
        inset-block-end: 0;
        inline-size: 100%;
        inset-inline-start: 0;
    }

    #text:empty::after {
        color: #ccc;
        content: 'Input text here and press enter to clear...';
    }

    #comments {
        display: grid;
    }

    #comments .commentBox {
        margin: 0;
        margin-block-start: 1em;
        border: solid .125rem #ccc;
        padding: .5em;
    }

    #comments .commentBox::before, #text::before {
        content: attr(data-short-id) ': ';
        color: #888;
    }

</style>
</head>
<body>
<h1>WebSocket chat demo</h1>
<div id="status">[<span id="connection">?</span>] You and <span id="online_count">0</span> user(s) online.</div>
<div id="text" contenteditable="true"></div>
<div id="comments"></div>
<script type="module">
    /**
     * @type {HTMLInputElement}
    */
    const textBox = document.querySelector('#text');
    const commentsContainer = document.querySelector('#comments');
    const connectionStatus = document.querySelector('#connection');
    const onlineCount = document.querySelector('#online_count');

    const getUuid = () => {
        const bytes = new Uint8Array(16);
        crypto.getRandomValues(bytes);
        bytes[6] = bytes[6] & 0x0f ^ 0x40;
        bytes[8] = bytes[8] & 0x3f ^ 0x80;
        const hex = Array.prototype.map.call(
            bytes,
            byte => ((byte | 0x100).toString(0x10)).slice(-2)
        ).join('');
        return [
            hex.substr(0, 8),
            hex.substr(8, 4),
            hex.substr(12, 4),
            hex.substr(16, 4),
            hex.substr(20, 12),
        ].join('-');
    };

    const getTime = () => +new Date;

    const UUID = getUuid();
    const PING_TIMEOUT = 30000;
    let lastUpdate = 0;
    textBox.dataset.uuid = UUID;
    textBox.dataset.shortId = UUID.split('-')[0];

    const wsUrl = new URL('/ws', location.href);
    wsUrl.protocol = 'https:' == wsUrl.protocol ? 'wss:' : 'ws:';

    /**
     * @type {WebSocket?}
     * */
    let ws;
    
    const showReadyState = readyState => {
        switch (readyState) {
            case WebSocket.CONNECTING:
                return 'CONNECTING';
            case WebSocket.OPEN:
                return 'OPEN';
            case WebSocket.CLOSING:
                return 'CLOSING';
            case WebSocket.CLOSED:
                return 'CLOSED';
            default:
                return 'UNKNOWN';
        }
    };

    const updateStatus = () => {
        console.log('readyState:', showReadyState(ws.readyState));
        connectionStatus.textContent = showReadyState(ws.readyState);
    }

    const sendMessage = data => {
        if (ws.readyState == WebSocket.OPEN) {
            ws.send(JSON.stringify(data));
            return true;
        } else {
            return false;
        }
    };

    let previousText = '';
    const sendUpdate = (force) => {
        const text = textBox.textContent.trim();
        if (text == previousText && !force) return;
        previousText = text;
        lastUpdate = getTime();
        if (text.length < 1) {
            sendMessage({
                uuid: UUID,
                command: 'text_cleared',
                text: '',
                time: getTime(),
            });
        } else {
            sendMessage({
                uuid: UUID,
                command: 'text_updated',
                text,
                time: getTime(),
            });
        }
    };

    const commit = () => {
        textBox.textContent = '';
        if (previousText == '') return;
        lastUpdate = getTime();
        previousText = '';
        sendMessage({
            uuid: UUID,
            command: 'text_cleared',
            text: '',
            time: getTime(),
        });
    };

    textBox.addEventListener('input', ev => {
        sendUpdate();
    });

    textBox.addEventListener('keydown', ev => {
        if (ev.keyCode == 13) {
            // ENTER
            ev.preventDefault();
            commit();
        }
    });

    textBox.addEventListener('blur', ev => {
        commit();
    });

    const textMap = Object.create(null);

    const getOnlineCount = () => Reflect.ownKeys(textMap).length;

    const renderText = () => {
        onlineCount.textContent = getOnlineCount();
        commentsContainer.textContent = '';
        for (const uuid of Reflect.ownKeys(textMap)) {
            if ('string' != typeof uuid) continue;
            const text = textMap[uuid].text;
            if ('' === text) continue;
            const commentBox = document.createElement('div');
            commentBox.classList.add('commentBox');
            commentBox.dataset.uuid = uuid;
            commentBox.dataset.shortId = uuid.split('-')[0];
            commentBox.append(text);
            commentsContainer.prepend(commentBox);
        }
    };

    const processMessage = ev => {
        //
        try {
            if ('string' != typeof ev.data) {
                throw 'Invalid data type';
            }

            const data = JSON.parse(ev.data);
            if ('object' != typeof data || !data) throw 'Invalid data';
            if ('string' != typeof data.uuid) throw 'Invalid UUID';
            if ('number' != typeof data.time) throw 'Invalid time';
            if ('string' != typeof data.command) throw 'Invalid command';
            
            const text = 'string' == typeof data.text ? data.text : '';
            switch (data.command) {
                case 'text_updated': {
                    textMap[data.uuid] = {
                        text,
                        receivedTime: getTime(),
                    };
                    renderText();
                    break;
                }
                case 'text_cleared': {
                    setTimeout(() => {
                        textMap[data.uuid] = {
                            text,
                            receivedTime: getTime(),
                        };
                        renderText();
                    }, 1000);
                    break;
                }
                default: {
                    console.warn('Unknown command');
                }
            }
        } catch (e) {
            console.error('Protocol violation:', e);
        }
    };

    const openSocket = () => {
        if (!ws || ws.readyState == WebSocket.CLOSED) {
            ws = new WebSocket(String(wsUrl));
            
            ws.addEventListener('open', ev => {
                console.log('ws: open');
                updateStatus();
            });
            ws.addEventListener('close', ev => {
                console.log('ws: close');
                updateStatus();
            });

            ws.addEventListener('message', processMessage);
        }
    };

    document.addEventListener('visibilitychange', ev => {
        if (!document.hidden) {
            console.log('Page is now visible!');
            openSocket();
        }
    });

    openSocket();

    setInterval(() => {
        const currentTime = getTime();
        if (currentTime - lastUpdate > 3000) {
            sendUpdate(true);
        }
        for (const uuid of Reflect.ownKeys(textMap)) {
            if (!textMap[uuid]) {
                delete textMap[uuid];
                continue;
            }
            const state = textMap[uuid];
            if (currentTime - state.receivedTime > 10000) {
                delete textMap[uuid];
                continue;
            }
        }

        renderText();
    }, 5000);

</script>
</body>
</html>