<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<title>Menhera Chatspace: realtime text chat</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="/menhera-icon.png"/>
<meta property="og:type" content="article"/>
<meta property="og:title" content="Menhera Chatspace"/>
<meta property="og:description" content="Menhera Chatspace is a realtime chat app where you can text like a voice call."/>
<meta property="og:image" content="https://menhera.io/menhera-icon.png"/>
<meta name="twitter:site" content="MenheraOrg"/>
<style>
    body, input, textarea, button, select {
        font: inherit;
        border-radius: 0;
    }

    pre {
        white-space: pre-wrap;
    }

    a {
        text-decoration: none;
        opacity: .75;
        color: inherit;
    }

    :root {
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 100%;
        display: grid;
        min-width: 100%;
        min-height: 100%;
        font-synthesis: none;
    }

    body {
        display: grid;
        margin: 0;
        grid-template-rows: max-content auto max-content;
    }

    #header {
        display: grid;
        grid-template-columns: max-content 1fr max-content;
        background-color: #5eaf30;
        color: #fff;
    }

    #logotype {
        font-weight: 500;
        padding: .5em;
    }

    #location {
        display: grid;
        grid-template-columns: max-content 1fr;
    }

    #location::before {
        display: block;
        padding: .5em;
        content: '#';
    }

    #random, #token {
        display: block;
        padding: .5em;
        inline-size: 100%;
        box-sizing: border-box;
        overflow: hidden;
        margin: 0;
    }

    #token {
        color: inherit;
        background-color: transparent;
        border: none;
        border-radius: 0;
        appearance: none;
    }

    #random {
        border: none;
        border-inline-start: solid .125rem rgba(0, 0, 0, .25);
        background-color: transparent;
        color: #fff;
    }

    #random:active, #random:hover {
        background-color: rgba(0, 0, 0, .25);
        border-inline-start-color: rgba(0, 0, 0, .5);
    }

    #token:focus {
        color: #666;
        background-color: rgba(255, 255, 255, .5);
    }

    #main {
        display: grid;
        align-content: end;
        background-color: #f2f2f2;
        padding: .5rem;
    }

    #controls {
        position: -webkit-sticky;
        position: sticky;
        bottom: 0;
        left: 0;
        right: 0;
        inline-size: 100%;
        background-color: #fff;
        display: grid;
        grid-template-columns: max-content 1fr;
    }

    #about {
        font-size: 75%;
    }

    #text {
        margin: 0;
        display: block;
        border: solid .125rem #aaa;
        padding: .5em;
        appearance: none;
        box-sizing: border-box;
        overflow: hidden;
        white-space: pre-wrap;
        grid-column-start: 1;
        grid-column-end: -1;
    }

    #name {
        appearance: none;
        display: block;
        border: solid .125rem #aaa;
        padding: .5em;
        box-sizing: border-box;
        overflow: hidden;
        margin: 0;
        border-radius: 0;
    }

    #text:empty::after {
        color: #ccc;
        content: 'Input text here and press enter to clear...';
    }

    #connection {
        background-color: #888;
        color: #fff;
        padding: .5em;
    }

    #connection[data-status="OPEN"] {
        background-color: #5eaf30;
    }

    #connection[data-status="OPEN"]::after {
        content: ' (You +' attr(data-online-count) ')';
    }

    #connection[data-status="OPEN"][data-online-count="0"]::after {
        content: ' (You are alone)';
    }

    #connection[data-status="CONNECTING"] {
        background-color: #b89930;
    }

    #comments {
        display: grid;
        align-content: end;
    }

    .commentBox {
        margin: 0;
        margin-block-end: 1em;
        border: solid .125rem #ccc;
        padding: .5em;
        background-color: #fff;
    }

    .commentBox::before {
        content: attr(data-name) ' #' attr(data-short-id) ': ';
        color: #888;
    }

    #members .commentBox {
        opacity: .75;
    }

    #text::before {
        content: '(#' attr(data-short-id) '): ';
        color: #888;
    }

</style>
</head>
<body>
<header id="header">
<div id="logotype">Chatspace</div>
<div id="location">
<input id="token" name="token" placeholder="(root)"/>
</div>
<button id="random">Random</button>
</header>
<main id="main">
<div id="comments"></div>
<div id="members"></div>
<section id="about">
<p>Menhera Chatspace is a realtime chat app where you can text like a voice call.</p>
<p>A <a href="https://www.menhera.org/">Menhera.org</a> project. Software copyright &copy; 2021 Menhera.org.</p>
<p>Terms of use: You agree to avoid any use of this service which make its continued development difficult, including but not limited to: illegal use.</p>
</section>
</main>
<div id="controls">
<div id="connection" data-online-count="0">Offline</div>
<input id="name" type="text" name="name" placeholder="Your name" title="Your name"/>
<div id="text" contenteditable="true" autofocus=""></div>
</div>
<script type="module">
    const textBox = document.querySelector('#text');

    /**
     * @type {HTMLInputElement}
    */
    const nameBox = document.querySelector('#name');

    /**
     * @type {HTMLInputElement}
     * */
    const tokenBox = document.querySelector('#token');

    const commentsContainer = document.querySelector('#comments');
    const membersContainer = document.querySelector('#members');
    const connectionStatus = document.querySelector('#connection');

    const getUuid = () => {
        const bytes = new Uint8Array(16);
        crypto.getRandomValues(bytes);
        bytes[6] = bytes[6] & 0x0f ^ 0x40;
        bytes[8] = bytes[8] & 0x3f ^ 0x80;
        const hex = Array.prototype.map.call(
            bytes,
            byte => ((byte | 0x100).toString(0x10)).slice(-2)
        ).join('');
        return [
            hex.substr(0, 8),
            hex.substr(8, 4),
            hex.substr(12, 4),
            hex.substr(16, 4),
            hex.substr(20, 12),
        ].join('-');
    };

    const getTime = () => +new Date;

    const getMyUuid = () => {
        try {
            const uuid = sessionStorage.getItem('menhera.chatspace.self.id');
            if (!uuid) {
                throw void 0;
            }
            return uuid;
        } catch (e) {
            const uuid = getUuid();
            sessionStorage.setItem('menhera.chatspace.self.id', uuid);
            return uuid;
        }
    };

    const UUID = getMyUuid();
    const PING_TIMEOUT = 30000;
    let lastUpdate = 0;
    textBox.dataset.uuid = UUID;
    textBox.dataset.shortId = UUID.split('-')[0];

    const wsUrl = new URL('/ws', location.href);
    wsUrl.protocol = 'https:' == wsUrl.protocol ? 'wss:' : 'ws:';

    try {
        const name = localStorage.getItem('menhera.chatspace.self.name');
        if (!name) throw void 0;
        console.log('Name restored.');
        nameBox.value = name;
    } catch (e) {
        console.log('Name not restored.');
    }

    const saveUsername = () => {
        try {
            localStorage.setItem('menhera.chatspace.self.name', nameBox.value);
        } catch (e) {
            console.warn('Failed to save your name:', e);
        }
    };

    nameBox.addEventListener('change', ev => {
        saveUsername();
    });

    tokenBox.addEventListener('change', ev => {
        const token = tokenBox.value.trim();
        if (token) {
            location.hash = `#${encodeURIComponent(token)}`;
        } else {
            location.hash = '';
        }
    });

    window.addEventListener('hashchange', ev => {
        const token = decodeURIComponent(location.hash.slice(1)).trim();
        tokenBox.value = token;
    });

    /**
     * @type {WebSocket?}
     * */
    let ws;
    
    const showReadyState = readyState => {
        switch (readyState) {
            case WebSocket.CONNECTING:
                return 'CONNECTING';
            case WebSocket.OPEN:
                return 'OPEN';
            case WebSocket.CLOSING:
                return 'CLOSING';
            case WebSocket.CLOSED:
                return 'CLOSED';
            default:
                return 'UNKNOWN';
        }
    };

    const updateStatus = () => {
        const status = showReadyState(ws.readyState);
        console.log('readyState:', status);
        connectionStatus.textContent = ws.readyState == WebSocket.OPEN ? `Online` : 'Offline';
        connectionStatus.dataset.status = status;
    };

    const sendMessage = data => {
        if (ws.readyState == WebSocket.OPEN) {
            ws.send(JSON.stringify(data));
            return true;
        } else {
            return false;
        }
    };

    let previousText = '';
    const sendUpdate = (force) => {
        const text = textBox.textContent.trim();
        const name = nameBox.value.trim();
        if (text == previousText && !force) return;
        previousText = text;
        lastUpdate = getTime();
        if (text.length < 1) {
            sendMessage({
                uuid: UUID,
                command: 'text_cleared',
                text: '',
                time: getTime(),
                name,
                isActive: !document.hidden,
            });
        } else {
            sendMessage({
                uuid: UUID,
                command: 'text_updated',
                text,
                time: getTime(),
                name,
                isActive: !document.hidden,
            });
        }
    };

    const commit = () => {
        textBox.textContent = '';
        const name = nameBox.value.trim();
        if (previousText == '') return;
        lastUpdate = getTime();
        previousText = '';
        sendMessage({
            uuid: UUID,
            command: 'text_cleared',
            text: '',
            time: getTime(),
            name,
            isActive: !document.hidden,
        });
    };

    textBox.addEventListener('input', ev => {
        sendUpdate();
    });

    textBox.addEventListener('keydown', ev => {
        if (ev.keyCode == 13) {
            // ENTER
            ev.preventDefault();
            commit();
        }
    });

    let blurTimeout;
    textBox.addEventListener('blur', ev => {
        if (!blurTimeout) {
            blurTimeout = setTimeout(() => {
                blurTimeout = void 0;
                commit();
            }, 15000);
        }
    });

    textBox.addEventListener('focus', ev => {
        if (blurTimeout) {
            clearTimeout(blurTimeout);
            blurTimeout = void 0;
        }
    });

    const textMap = Object.create(null);

    const getOnlineCount = () => Reflect.ownKeys(textMap).length;

    const renderText = () => {
        connectionStatus.dataset.onlineCount = getOnlineCount();
        commentsContainer.textContent = '';
        membersContainer.textContent = '';
        for (const uuid of Reflect.ownKeys(textMap)) {
            if ('string' != typeof uuid) continue;
            const state = textMap[uuid];
            if (!state) continue;
            const text = state.text;
            const name = state.name || '';
            const isActive = !!state.isActive;
            if ('' === text && ('' === name || !isActive)) {
                continue;
            }
            const commentBox = document.createElement('div');
            commentBox.classList.add('commentBox');
            commentBox.dataset.uuid = uuid;
            commentBox.dataset.name = name || 'Anonymous';
            commentBox.dataset.shortId = uuid.split('-')[0];
            commentBox.title = uuid;
            commentBox.append(text);
            if (text) {
                commentsContainer.prepend(commentBox);
            } else {
                membersContainer.prepend(commentBox);
            }
        }
    };

    const processMessage = ev => {
        //
        try {
            if ('string' != typeof ev.data) {
                throw 'Invalid data type';
            }

            const data = JSON.parse(ev.data);
            if ('object' != typeof data || !data) throw 'Invalid data';
            if ('string' != typeof data.uuid) throw 'Invalid UUID';
            if ('number' != typeof data.time) throw 'Invalid time';
            if ('string' != typeof data.command) throw 'Invalid command';
            
            const text = 'string' == typeof data.text ? data.text : '';
            const name = data.name || '';
            switch (data.command) {
                case 'text_updated': {
                    textMap[data.uuid] = {
                        text,
                        name,
                        receivedTime: getTime(),
                        isActive: data.isActive,
                    };
                    renderText();
                    break;
                }
                case 'text_cleared': {
                    setTimeout(() => {
                        textMap[data.uuid] = {
                            text,
                            receivedTime: getTime(),
                            name,
                            isActive: data.isActive,
                        };
                        renderText();
                    }, 1000);
                    break;
                }
                default: {
                    console.warn('Unknown command');
                }
            }
        } catch (e) {
            console.error('Protocol violation:', e);
        }
    };

    const openSocket = () => {
        if (!ws || ws.readyState == WebSocket.CLOSED) {
            ws = new WebSocket(String(wsUrl));
            
            ws.addEventListener('open', ev => {
                console.log('ws: open');
                updateStatus();
            });
            ws.addEventListener('close', ev => {
                console.log('ws: close');
                updateStatus();
            });

            ws.addEventListener('message', processMessage);
        }
    };

    document.addEventListener('visibilitychange', ev => {
        if (!document.hidden) {
            console.log('Page is now visible!');
            openSocket();
        }
    });

    window.addEventListener('pageshow', ev => {
        console.log('pageshow');
        saveUsername();
        openSocket();
    });

    setInterval(() => {
        const currentTime = getTime();
        if (currentTime - lastUpdate > 3000) {
            sendUpdate(true);
        }
        for (const uuid of Reflect.ownKeys(textMap)) {
            if (!textMap[uuid]) {
                delete textMap[uuid];
                continue;
            }
            const state = textMap[uuid];
            if (currentTime - state.receivedTime > 10000) {
                delete textMap[uuid];
                continue;
            }
        }

        renderText();
    }, 4000);

</script>
</body>
</html>